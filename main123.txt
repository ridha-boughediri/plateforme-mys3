package main

import (
	"context"
	"fmt"
	"log"
	"plateforme-mys3/handlers"
	"plateforme-mys3/storage"

	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql" // Importer le pilote MySQL
	"github.com/minio/minio-go/v7"
	"github.com/minio/minio-go/v7/pkg/credentials"
)

func main() {
	// Configuration du DSN pour MySQL
	dsn := "root:@tcp(127.0.0.1:3306)/mys3db?charset=utf8mb4&parseTime=True&loc=Local"

	// Initialiser la base de données MySQL
	db, err := storage.InitDB(dsn)
	if err != nil {
		log.Fatalf("Could not connect to the database: %v", err)
	}

	// Migrer les tables nécessaires
	if err := storage.Migrate(db); err != nil {
		log.Fatalf("Could not migrate database: %v", err)
	}

	// Configuration du client MinIO
	endpoint := "localhost:9000"
	accessKeyID := "admin"
	secretAccessKey := "admin"
	useSSL := false

	// Initialiser le client MinIO
	minioClient, err := minio.New(endpoint, &minio.Options{
		Creds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, ""),
		Secure: useSSL,
	})
	if err != nil {
		log.Fatalln(err)
	}

	fmt.Println("Successfully connected to MinIO")

	// Nom du bucket
	bucketName := "mybucket"
	location := "us-east-1"

	// Créer un bucket
	err = minioClient.MakeBucket(context.Background(), bucketName, minio.MakeBucketOptions{Region: location})
	if err != nil {
		exists, errBucketExists := minioClient.BucketExists(context.Background(), bucketName)
		if errBucketExists == nil && exists {
			log.Printf("Bucket %s already exists\n", bucketName)
		} else {
			log.Fatalln(err)
		}
	} else {
		log.Printf("Successfully created bucket %s\n", bucketName)
	}

	// Opérations de fichiers (exemple)
	uploadFile(minioClient, bucketName)
	downloadFile(minioClient, bucketName)
	deleteFile(minioClient, bucketName)

	// Créer un routeur Gin
	r := gin.Default()

	// Définir les routes pour les produits (exemple existant)
	r.GET("/products", func(c *gin.Context) {
		handlers.GetProductsGin(c, db)
	})
	r.POST("/products", func(c *gin.Context) {
		handlers.CreateProductGin(c, db)
	})
	r.PUT("/products/:id", func(c *gin.Context) {
		handlers.UpdateProductGin(c, db)
	})
	r.DELETE("/products/:id", func(c *gin.Context) {
		handlers.DeleteProductGin(c, db)
	})

	// Définir les routes pour la gestion des buckets
	r.POST("/buckets/:name", func(c *gin.Context) {
		handlers.CreateBucketGin(c, db)
	})
	r.GET("/buckets", func(c *gin.Context) {
		handlers.ListBucketsGin(c, db)
	})
	r.DELETE("/buckets/:name", func(c *gin.Context) {
		handlers.DeleteBucketGin(c, db)
	})

	// Définir les routes pour la gestion des fichiers dans les buckets
	r.POST("/buckets/:name/upload", func(c *gin.Context) {
		handlers.UploadFileGin(c, db)
	})
	r.GET("/buckets/:name/files", func(c *gin.Context) {
		handlers.ListFilesGin(c, db)
	})
	r.GET("/buckets/:name/files/:file", func(c *gin.Context) {
		handlers.DownloadFileGin(c, db)
	})
	r.DELETE("/buckets/:name/files/:file", func(c *gin.Context) {
		handlers.DeleteFileGin(c, db)
	})

	// Démarrer le serveur
	log.Println("API is running on port 8080...")
	if err := r.Run(":8080"); err != nil {
		log.Fatal("Unable to start server:", err)
	}
}

// Fonction pour uploader un fichier
func uploadFile(minioClient *minio.Client, bucketName string) {
	objectName := "example.txt"
	filePath := "C:\\Data\\example.txt" // Remplacez par le chemin réel de votre fichier
	contentType := "text/plain"

	info, err := minioClient.FPutObject(context.Background(), bucketName, objectName, filePath, minio.PutObjectOptions{ContentType: contentType})
	if err != nil {
		log.Fatalln(err)
	}

	log.Printf("Successfully uploaded %s of size %d\n", objectName, info.Size)
}

// Fonction pour télécharger un fichier
func downloadFile(minioClient *minio.Client, bucketName string) {
	objectName := "example.txt"
	err := minioClient.FGetObject(context.Background(), bucketName, objectName, "C:\\Data\\downloaded_example.txt", minio.GetObjectOptions{})
	if err != nil {
		log.Fatalln(err)
	}

	log.Printf("Successfully downloaded %s\n", objectName)
}

// Fonction pour supprimer un fichier
func deleteFile(minioClient *minio.Client, bucketName string) {
	objectName := "example.txt"
	err := minioClient.RemoveObject(context.Background(), bucketName, objectName, minio.RemoveObjectOptions{})
	if err != nil {
		log.Fatalln(err)
	}

	log.Printf("Successfully deleted %s\n", objectName)
}



package main

// import (
// 	"encoding/json"
// 	"log"
// 	"net/http"
// 	"os"

// 	"github.com/joho/godotenv"
// 	"github.com/minio/minio-go/v7"
// 	"github.com/minio/minio-go/v7/pkg/credentials"
// )

// var minioClient *minio.Client

// func initMinioClient() (*minio.Client, error) {
// 	endpoint := os.Getenv("AZURE_S3_ENDPOINT")
// 	accessKeyID := os.Getenv("MINIO_ROOT_USER")
// 	secretAccessKey := os.Getenv("MINIO_ROOT_PASSWORD")
// 	useSSL := os.Getenv("AZURE_USE_SSL") == "true"

// 	client, err := minio.New(endpoint, &minio.Options{
// 		Creds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, ""),
// 		Secure: useSSL,
// 	})
// 	if err != nil {
// 		return nil, err
// 	}

// 	return client, nil
// }

// func createBucketHandler(w http.ResponseWriter, r *http.Request) {
// 	bucketName := r.URL.Query().Get("bucket")
// 	if bucketName == "" {
// 		http.Error(w, "Bucket name is required", http.StatusBadRequest)
// 		return
// 	}

// 	ctx := r.Context()
// 	err := minioClient.MakeBucket(ctx, bucketName, minio.MakeBucketOptions{})
// 	if err != nil {
// 		http.Error(w, err.Error(), http.StatusInternalServerError)
// 		return
// 	}

// 	w.WriteHeader(http.StatusCreated)
// 	json.NewEncoder(w).Encode(map[string]string{"message": "Bucket created successfully"})
// 	log.Printf("Bucket %s created successfully", bucketName)
// }

// func listBucketsHandler(w http.ResponseWriter, r *http.Request) {
// 	ctx := r.Context()
// 	buckets, err := minioClient.ListBuckets(ctx)
// 	if err != nil {
// 		http.Error(w, err.Error(), http.StatusInternalServerError)
// 		return
// 	}

// 	var bucketNames []string
// 	for _, bucket := range buckets {
// 		bucketNames = append(bucketNames, bucket.Name)
// 	}

// 	w.Header().Set("Content-Type", "application/json")
// 	json.NewEncoder(w).Encode(bucketNames)
// 	log.Println("Buckets listed successfully")
// }

// func uploadFileHandler(w http.ResponseWriter, r *http.Request) {
// 	// Limite la taille du fichier à 10MB
// 	r.ParseMultipartForm(10 << 20) // 10MB

// 	bucketName := r.FormValue("bucket")
// 	if bucketName == "" {
// 		http.Error(w, "Bucket name is required", http.StatusBadRequest)
// 		return
// 	}

// 	file, handler, err := r.FormFile("file")
// 	if err != nil {
// 		http.Error(w, "Failed to retrieve file from form: "+err.Error(), http.StatusBadRequest)
// 		return
// 	}
// 	defer file.Close()

// 	ctx := r.Context()

// 	// Vérifier si le bucket existe
// 	exists, err := minioClient.BucketExists(ctx, bucketName)
// 	if err != nil {
// 		http.Error(w, "Failed to check bucket: "+err.Error(), http.StatusInternalServerError)
// 		return
// 	}

// 	if !exists {
// 		http.Error(w, "Bucket does not exist", http.StatusNotFound)
// 		return
// 	}

// 	// Upload du fichier vers le bucket
// 	_, err = minioClient.PutObject(ctx, bucketName, handler.Filename, file, handler.Size, minio.PutObjectOptions{ContentType: "application/octet-stream"})
// 	if err != nil {
// 		http.Error(w, "Failed to upload file: "+err.Error(), http.StatusInternalServerError)
// 		return
// 	}

// 	w.WriteHeader(http.StatusOK)
// 	json.NewEncoder(w).Encode(map[string]string{"message": "File uploaded successfully"})
// 	log.Printf("File %s uploaded successfully to bucket %s", handler.Filename, bucketName)
// }

// func main() {
// 	// Charger les variables d'environnement depuis le fichier .env
// 	err := godotenv.Load()
// 	if err != nil {
// 		log.Fatalf("Error loading .env file: %v", err)
// 	}

// 	// Initialiser le client MinIO
// 	minioClient, err = initMinioClient()
// 	if err != nil {
// 		log.Fatalf("Failed to initialize MinIO client: %v", err)
// 	}

// 	// Configurer les routes HTTP
// 	http.HandleFunc("/create-bucket", createBucketHandler)
// 	http.HandleFunc("/list-buckets", listBucketsHandler)
// 	http.HandleFunc("/upload-file", uploadFileHandler)

// 	// Démarrer le serveur HTTP
// 	log.Println("Server is running on port 3000")
// 	log.Fatal(http.ListenAndServe(":3000", nil))
// }
